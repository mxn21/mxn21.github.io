---
layout: post
author: mxn
titile: 理解快速排序算法
category: 技术博文
tag: 算法
---

快速排序在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比
其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。

步骤为：

1.从数列中挑出一个元素，称为"基准"（pivot），
2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition
）操作。
3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

效果图如下：

![](http://baobaoloveyou.com/img187.gif)

<!-- more -->  

### partition方法

partition方法是快速排序算法的核心，下面先写一个简单的原地（in-place）分区的版本。

    {% highlight java %} 
public class Test1 {
    public static void main(String args[]) {
            int[] a = {354,656,21,2342,65,657,76,12,54,778,50,31,333,45,56,86,97,121} ;
            System.out.print(partition(a,2)) ;
    }
    static int partition(int arr[], int pivotIndex)
    {
        int start = 0 ;
        int end = arr.length - 1 ;
        int pivot = arr[pivotIndex];
        swap(arr,pivotIndex, end);
        int storeIndex = start;
        for(int i = start; i < end; ++i) {
            if(arr[i] < pivot) {
                swap(arr,i, storeIndex);
                ++storeIndex;
            }
        }
        swap(arr,storeIndex, end);
        return storeIndex;
    }
    public  static  void  swap ( int [] data,  int  a,  int  b) {
        int  t = data [a];
        data [a] = data [b];
        data [b] = t;
    }
}
   {% endhighlight %} 
   
首先注意swap方法，swap方法用于交换数组中的两个元素。

partition当中调用了三次swap，我们随机选中一个位置作为"基准"（pivot）,第一次交换就是把这个pivot交换到数组最后一位。
第三次当然就是把它从最后一位交换到它应该在的位置。中间的for循环是这个方法的核心。

storeIndex就是最后pivot摆放的位置。storeIndex前面的元素都比pivot小，storeIndex之后的元素都比pivot大。
所以我们从第一个元素遍历到最后一个，目的是把全部元素分成两段，storeIndex位于两段中间，第一段全部是是小于pivot的元素，
第二段都是大于pivot的元素，完成分段之后在把pivot从最后一个位置交换到两段中间。
循环时发现元素小于pivot，就把元素移动到后半段子序列的开头，然后把后半段开头的标记位storeIndex＋1。这就是for循环里的工作。

要注意的是，一个元素在到达它的最后位置前，可能会被交换很多次。一旦我们有了这个分区算法，要写快速排列本身就很容易。

### 完整的快排算法






