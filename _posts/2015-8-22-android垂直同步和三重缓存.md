---
layout: post
author: mxn
titile: android渲染机制和丢帧分析
category: 技术博文
tag: android
---

作为严重影响Android口碑问题之一的UI流畅性差的问题，首先在Android 4.1版本中得到了有效处理。其解决方法就是本文要介绍的Project Butter。

Project Butter对Android Display系统进行了重构，引入了三个核心元素，即VSYNC、Triple Buffer和Choreographer。其中，
VSYNC是理解Project Buffer的核心。VSYNC是Vertical Synchronization（垂直同步）的缩写，是一种在PC上已经很早就广泛使用的技术。
可简单的把它认为是一种定时中断。

接下来，将围绕VSYNC来介绍Android Display系统的工作方式。请注意，后续讨论将以Display为基准，将其划分成16ms长度的时间段，
在每一时间段中，Display显示一帧数据（相当于每秒60帧）。时间段从1开始编号。

首先是没有VSYNC的情况:

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img77.png)

由上图可知

1.时间从0开始，进入第一个16ms：Display显示第0帧，CPU处理完第一帧后，GPU紧接其后处理继续第一帧。三者互不干扰，一切正常。
2.时间进入第二个16ms：因为早在上一个16ms时间内，第1帧已经由CPU，GPU处理完毕。故Display可以直接显示第1帧。显示没有问题。但在本16ms期间，CPU和GPU
却并未及时去绘制第2帧数据（注意前面的空白区），而是在本周期快结束时，CPU/GPU才去处理第2帧数据。
3.时间进入第3个16ms，此时Display应该显示第2帧数据，但由于CPU和GPU还没有处理完第2帧数据，故Display只能继续显示第一帧的数据，结果使得第1
帧多画了一次（对应时间段上标注了一个Jank）。
4.通过上述分析可知，此处发生Jank的关键问题在于，为何第1个16ms段内，CPU/GPU没有及时处理第2帧数据？原因很简单，CPU可能是在忙别的事情（比如某个应用通过sleep
固定时间来实现动画的逐帧显示），不知道该到处理UI绘制的时间了。可CPU一旦想起来要去处理第2帧数据，时间又错过了！

为解决这个问题，Project Buffer引入了VSYNC，这类似于时钟中断。结果如图所示：

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img78.png)

由图可知，每收到VSYNC中断，CPU就开始处理各帧数据。整个过程非常完美。
不过，仔细琢磨图2却会发现一个新问题：图2中，CPU和GPU处理数据的速度似乎都能在16ms内完成，而且还有时间空余，也就是说，CPU/GPU的FPS（帧率，Frames Per Second）要高于Display的FPS。确实如此。由于CPU/GPU只在收到VSYNC时才开始数据处理，故它们的FPS被拉低到与Display的FPS相同。但这种处理并没有什么问题，因为Android设备的Display FPS一般是60，其对应的显示效果非常平滑。
如果CPU/GPU的FPS小于Display的FPS，会是什么情况呢？请看下图：

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img79.png)







