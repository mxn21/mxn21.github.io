---
layout: post
author: mxn
titile: 理解kmp算法
category: 技术博文
tag: 算法
---

“KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置.KMP算法是一种线性时间复杂的字符串匹配算法，
它是对BF算法（Brute-Force，最基本的字符串匹配算法的）改进。对于给的原始串S和模式串P，需要从字符串S中找到字符串P出现的位置的索引。

### BF算法与KMP算法的区别

BF算法的时间复杂度O(strlen(S) * strlen(T))，空间复杂度O(1)。

KMP算法的时间复杂度O(strlen(S) + strlen(T))，空间复杂度O(strlen(T))。

假设现在S串匹配到i位置，T串匹配到j位置。那么总的来说，两种算法的主要区别在于失配的情况下，对[j] 的值做的处理
（注意，本文中的字符串下标都是从0开始计算）：BF算法中，如果当前字符匹配成功，即s[i+j] == T[j]，令j++，继续匹配下一个字符；
如果失配，即S[i + j] != T[j]，需要让i++,并且j= 0，即每次匹配失败的情况下，模式串T相对于原始串S向右移动了一位。
而KMP算法中，如果当前字符匹配成功，即S[i]==T[j]，令i++，j++，继续匹配下一个字符；如果匹配失败，即S[i] != T[j]，
需要保持i不变，并且让j = next[j]，这里next[j] <=j -1，即模式串T相对于原始串S向右移动了至少1位(移动的实际位数j - next[j]  >=1),
同时移动之后，i之前的部分（即S[i-j+1 ~ i-1]），和j=next[j]之前的部分（即T[0 ~ j-2]）仍然相等。
显然，相对于BF算法来说，KMP移动更多的位数，起到了一个加速的作用！ (失配的特殊情形，令j=next[j]导致j==0的时候，
需要将i ++，否则此时没有移动模式串)。

