---
layout: post
author: mxn
titile: 理解kmp算法
category: 技术博文
tag: 算法
---

“KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置.KMP算法是一种线性时间复杂的字符串匹配算法，
它是对BF算法（Brute-Force，最基本的字符串匹配算法的）改进。对于给的原始串S和模式串P，需要从字符串S中找到字符串P出现的位置的索引。

### BF算法与KMP算法的区别

BF算法的时间复杂度O(strlen(S) * strlen(T))，空间复杂度O(1)。

KMP算法的时间复杂度O(strlen(S) + strlen(T))，空间复杂度O(strlen(T))。

字符串匹配算法必须要回溯。但回溯就影响了效率，回溯是由T串本身的性质决定的，是因为T串本身有前后'部分匹配'的性质。
改进的地方也就是这里，我们从T串本身出发，事先就找准了T自身前后部分匹配的位置，那就可以改进算法。
KMP算法就是利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。

### 算法流程事例

1.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img163.png)

首先，字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。

2.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img164.png)

因为B与A不匹配，搜索词再往后移。

3.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img165.png)

就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。

4.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img166.png)

接着比较字符串和搜索词的下一个字符，还是相同。

5.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img167.png)

直到字符串有一个字符，与搜索词对应的字符不相同为止。

6.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img168.png)

这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把"搜索位置"移
到已经比较过的位置，重比一遍。

7.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img169.png)

一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是"ABCDAB"。KMP算法的想法是，设法利用这个已知信息，
不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率。

8.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img170.png)
怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。

9.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img171.png)

已知空格与D不匹配时，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符B对应的"部分匹配值"为2，因此按照下面的公式算出向后移动的位数：

`移动位数 = 已匹配的字符数 - 对应的部分匹配值`

因为 6 - 2 等于4，所以将搜索词向后移动4位。

10.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img172.png)

因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（"AB"），对应的"部分匹配值"为0。所以，
移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。

11.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img173.png)

因为空格与A不匹配，继续后移一位。

12.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img174.png)

逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。


13.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img175.png)

逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），
移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。


### 部分匹配表

下面介绍《部分匹配表》是如何产生的。
首先，要了解两个概念："前缀"和"后缀"。 "前缀"指除了最后一个字符以外，一个字符串的全部头部组合；
"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img176.png)

"部分匹配值"就是"前缀"和"后缀"的最长的共有元素的长度，其前后缀都是表示完全前后缀，即不包含自身的前缀或者后缀。
下面以下图为例详细讲解一下

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img177.png)

为了方便说明这里把搜索词记为：P={ABCDABD}.

1.P[0]表示“A”，其完全前后缀都是空，所以其部分匹配值为0  
2.P[1]表示“AB”，其完全前缀为{空，A}，完全后缀为{B，空}，前后缀中只有空相同，所以AB(即P[1])的匹配值为0  
3.P[2]表示“ABC”，其完全前缀为{空，A，AB}，完全后缀为{BC，B，空}，前后缀中只有空相同，所以ABC(即P[2])的匹配值为0  
4.P[3]表示“ABCD”，其完全前缀为{空，A，AB，ABC}，完全后缀为{BCD，CD，D，空}，前后缀中只有空相同，所以ABCD(即P[3])的匹配值为0  
5.P[4]表示“ABCDA”，其完全前缀为{空，A，AB，ABC，ABCD}，完全后缀为{BCDA，CDA，DA，A，空}，前后缀中都有{A}长度为1，所以ABCDA(即P[4])的匹配值为1  
6.P[5]表示“ABCDAB”其完全前缀为{空，A，AB，ABC，ABCD，ABCDA}，完全后缀为{BCDAB，CDAB，DAB，AB，B，空}，前后缀中都有{AB}长度为2
，所以ABCDAB(即P[5])的匹配值为2  
7.P[6]表示“ABCDABD”其完全前缀为{空，A，AB，ABC，ABCD，ABCDA，ABCDAB}，完全后缀为{BCDABD，CDABD，DABD，ABD，BD，D
，空}，前后缀中只有空相同，所以ABCDABD(即P[6])的匹配值为0  

说明：
P[i]表示能匹配的字符串，部分匹配值计算的是能匹配的字符串对应该的值，例如上面的P[5]表示的是如果匹配了字符串“ABCDAB”，
则这个字符串对应的部分匹配值为2，而不是第二个字符B的部分匹配值.
为了方便操作，字符串的部分匹配值都对应到字符串的最后一个字符，这样即方便记录也方便查询

"部分匹配"的实质是，有时候，字符串头部和尾部会有重复。比如，"ABCDAB"之中有两个"AB"，那么它的"部分匹配值"就是2（"AB"的长度）。
搜索词移动的时候，第一个"AB"向后移动4位（字符串长度-部分匹配值），就可以来到第二个"AB"的位置。

### next数组的求解思路

通过上文完全可以对kmp算法的原理有个清晰的了解，那么下一步就是编程实现了，其中最重要的就是如何根据待匹配的模版字符串求
出对应每一位的最大相同前后缀的长度。我先给出我的代码：

    {% highlight java %}  
 public static int[] makeNext(String ps) {
        int q, k;//q:模版字符串下标；k:最大前后缀长度
        char[] p = ps.toCharArray();
        int m = p.length;//模版字符串长度
        int[] next = new int[m];
        next[0] = 0;//模版字符串的第一个字符的最大前后缀长度为0
        for (q = 1, k = 0; q < m; ++q)//for循环，从第二个字符开始，依次计算每一个字符对应的next值
        {
            while (k > 0 && p[q] != p[k]) {//递归的求出P[0]···P[q]的最大的相同的前后缀长度k
                k = next[k - 1];           //关键
            }
            if (p[q] == p[k])//如果相等，那么最大相同前后缀长度加1
            {
                k++;
            }
            next[q] = k;
        }
        return next;
    }
     {% endhighlight %} 

next函数有多种不同的版本，有第一位从0开始的，也有从-1开始的，这里用next数组的，next数组是以下标0开始的！

现在我着重讲解一下makeNext方法所做的工作，如果觉得不好理解就多举几个例子输出一下数组。

我们先从简单的字符串开始，第一个例子是 ABCDABCE

调用如下代码输出：

    {% highlight java %}  
System.out.print( Arrays.toString(makeNext("ABCDABCE")));
     {% endhighlight %} 

