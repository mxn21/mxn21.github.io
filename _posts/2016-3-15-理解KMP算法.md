---
layout: post
author: mxn
titile: 理解kmp算法
category: 技术博文
tag: 算法
---

“KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置.KMP算法是一种线性时间复杂的字符串匹配算法，
它是对BF算法（Brute-Force，最基本的字符串匹配算法的）改进。对于给的原始串S和模式串P，需要从字符串S中找到字符串P出现的位置的索引。

### BF算法与KMP算法的区别

BF算法的时间复杂度O(strlen(S) * strlen(T))，空间复杂度O(1)。

KMP算法的时间复杂度O(strlen(S) + strlen(T))，空间复杂度O(strlen(T))。

字符串匹配算法必须要回溯。但回溯就影响了效率，回溯是由T串本身的性质决定的，是因为T串本身有前后'部分匹配'的性质。
改进的地方也就是这里，我们从T串本身出发，事先就找准了T自身前后部分匹配的位置，那就可以改进算法。
KMP算法就是利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。

### 算法流程事例

1.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img163.png)

首先，字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。

2.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img164.png)

因为B与A不匹配，搜索词再往后移。

3.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img165.png)

就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。

4.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img166.png)

接着比较字符串和搜索词的下一个字符，还是相同。

5.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img167.png)

直到字符串有一个字符，与搜索词对应的字符不相同为止。

6.
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img168.png)

这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把"搜索位置"移
到已经比较过的位置，重比一遍。








