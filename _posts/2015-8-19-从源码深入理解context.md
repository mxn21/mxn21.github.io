---
layout: post
author: mxn
titile: 从源码深入理解context
category: 技术博文
tag: android
---

## Context是什么

我们可以理解为“上下文”：它贯穿整个应用；
也可以理解成“运行环境”：它提供了一个应用运行所需要的信息，资源，系统服务等；
同样可以理解成“场景”：用户操作和系统交互这一过程就是一个场景，比如Activity之间的切换，服务的启动等都少不了Context。

然而以上这些都是我们从抽象角度去理解Context的作用，那么从Code代码来看Context到底是什么呢？Activity是一个Context，Application是一个Context
，Service也是一个Context.

   {% highlight java  %}
public abstract class Context {
..............................
 /** Return an AssetManager instance for your application's package. */
    public abstract AssetManager getAssets();

    /** Return a Resources instance for your application's package. */
    public abstract Resources getResources();

    /** Return PackageManager instance to find global package information. */
    public abstract PackageManager getPackageManager();

    /** Return a ContentResolver instance for your application's package. */
    public abstract ContentResolver getContentResolver();

...................
//获取系统服务
public abstract Object getSystemService(@ServiceName @NonNull String name);
//发送广播
public abstract void sendBroadcast(Intent intent);
//启动Activity
public abstract void startActivity(Intent intent);
//启动服务，绑定服务
public abstract ComponentName startService(Intent service);
public abstract boolean bindService(Intent service, @NonNull ServiceConnection conn,
            @BindServiceFlags int flags);

................
}

   {% endhighlight %}

<!-- more -->

从源码看Context就是一个抽象类，里面定义了各种抽象方法，包括获取系统资源，获取系统服务，发送广播，启动Activity,Service等。
所以从源码角度看Context就是抽象出一个App应用所有功能的集合，由于Context是一个纯的抽象类，
所以它的具体的方法实现是在其之类ContextImpl中实现了，稍后分析。我们平时在MainActivity中会这么给mContext = this赋值，
其言外之意就是当前Activity类就是Context，那说明Activity是Context的子类。通过Android Studio查看Context的子类图如下：

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img65.png)

有图可知，Context的子类很多，我们主要分析以上红色矩形框内的即可。接下来就分析Android系统中Context的继承关系！

## Android系统中Context的继承关系

有上一节我们知道，Activity是一个Context，Service也是一个Context等等，那么这些类跟Context具体什么关系呢？接下来有一幅图Context继承关系图来说明：

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img66.png)

Context类是一个抽象类，具体实现在ContextImpl类中；而ContextWrapper是Context的一个包装类，
其里面所有的方法实现都是调用其内部mBase变量的方法，而mBase就是ContextImpl对象，稍后分析。
然而ContextWrapper还有一个ContextThemeWrapper子类，该类中扩展了主题相关的方法。有继承关系图可以看出，
Application和Service是继承自ContextWrapper，而Activity是继承自ContextThemeWrapper，
Activity在启动的时候系统都会加载一个主题，也就是我们平时在AndroidManifest.xml文件里面写的android:theme="@style/AppTheme"属性.
然而Service和Applicaton都和UI界面并没有关系！因此他们继承自ContextWrapper。所以Activity，Application，
Service其实都关联着一个mBase变量，而mBase变量是ContextImpl对象的赋值，
也是真正实现抽象类Context的地方。虽然Activity，Application，Service都有一个共同的祖先Context，
但是他们自己本身持有的Context对象是不同的，接下来我们从源码角度分析以上几个类的实现。

## 不同Context源码分析

#### ContextImpl—真正实现Context功能的类

从源码看出Context类仅仅是定义了一组抽象方法的抽象类，其内部的方法真正实现的地方都在ContextImpl类中。

   {% highlight java  %}
class ContextImpl extends Context {
    //整个App的主线程
    final ActivityThread mMainThread;
    //整个App的相关信息
    final LoadedApk mPackageInfo;
    //资源解析器
    private final ResourcesManager mResourcesManager;
    //App资源类
    private final Resources mResources;
    //外部Context的引用
    private Context mOuterContext;
    //默认主题
    private int mThemeResource = 0;
    private Resources.Theme mTheme = null;
    //包管理器
    private PackageManager mPackageManager;

    ................................
//以下是静态区注册系统的各种服务，多大五六十种系统服务，因此每个持有Context引用的对象都可以随时通过getSystemService方法来轻松获取系统服务。
static {
        registerService(ACCESSIBILITY_SERVICE, new ServiceFetcher() {
                public Object getService(ContextImpl ctx) {
                    return AccessibilityManager.getInstance(ctx);
                }});

        registerService(CAPTIONING_SERVICE, new ServiceFetcher() {
                public Object getService(ContextImpl ctx) {
                    return new CaptioningManager(ctx);
                }});

        registerService(ACCOUNT_SERVICE, new ServiceFetcher() {
                public Object createService(ContextImpl ctx) {
                    IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);
                    IAccountManager service = IAccountManager.Stub.asInterface(b);
                    return new AccountManager(ctx, service);
                }});
        ........................

       }

.................
//启动Activity的地方
 @Override
    public void startActivity(Intent intent, Bundle options) {
        warnIfCallingFromSystemProcess();
        if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
            throw new AndroidRuntimeException(
                    "Calling startActivity() from outside of an Activity "
                    + " context requires the FLAG_ACTIVITY_NEW_TASK flag."
                    + " Is this really what you want?");
        }
        mMainThread.getInstrumentation().execStartActivity(
            getOuterContext(), mMainThread.getApplicationThread(), null,
            (Activity)null, intent, -1, options);
    }

..........
//启动服务的地方
@Override
    public ComponentName startService(Intent service) {
        warnIfCallingFromSystemProcess();
        return startServiceCommon(service, mUser);
    }
...............
}
   {% endhighlight %}

分析：ContextImpl实现了抽象类Context里面的所有方法，获取资源，启动Activity，Service等。
值得注意的是在ContextImpl创建的时候就会利用静态区来注册系统的各种服务，
因此每个持有Context引用的类都可以通过getSystemService来轻松的获取系统服务了。
比如我们平时LayoutInflater类来加载一个XML布局时时这么写的.

   {% highlight java  %}
LayoutInflater inflater = LayoutInflater.from(mContext);
View layout = inflater.inflate(R.layout.activity_main,null);
   {% endhighlight %}

其实源码内部是这样实现的：

   {% highlight java  %}
/**
     * Obtains the LayoutInflater from the given context.
     */
    public static LayoutInflater from(Context context) {
        LayoutInflater LayoutInflater =
                (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        if (LayoutInflater == null) {
            throw new AssertionError("LayoutInflater not found.");
        }
        return LayoutInflater;
    }
     {% endhighlight %}

可以看出LayoutInflater布局加载器也是调用context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
来获取系统服务得到的。因此我们以后在代码中也可以这么来加载一个XML布局：

