---
layout: post
author: mxn
title: android单例模式分析
category: 技术博文
tag: [android]
---

####作用
单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点


####适用场景
1. 应用中某个实例对象需要频繁的被访问。

2. 应用中每次启动只会存在一个实例。如数据库系统。

####使用方式

1. 懒汉式

{% highlight java %}

public class Singleton {  
  
    /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */  
    private static Singleton instance = null;  
  
    /* 私有构造方法，防止被实例化 */  
    private Singleton() {  
    }  
  
    /* 懒汉式，静态工程方法，创建实例 */  
    public static Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
}  

	{% endhighlight %}

调用：
{% highlight java %}

Singleton.getInstance() ;

{% endhighlight %}

优点：延迟加载（需要的时候才去加载）
缺点： 线程不安全，在多线程中很容易出现不同步的情况，如在数据库对象进行的频繁读写操作时。

2. 懒汉式变种,加同步锁


{% highlight java %}

public class Singleton {    
  
   private static Singleton instance = null;    
     
    public synchronized static Singleton getInstance() {    
        if (instance == null) {    
            instance = new Singleton();    
        }    
        return instance;    
    }    
}   

{% endhighlight %}

更一般的写法是这样
{% highlight java %}
public class Singleton {    
  
   private static Singleton instance = null;    
     
   public static Singleton getInstance() {  
     synchronized (Singleton.class) {  
         if (instance == null) {  
             instance = new Singleton();  
         }  
     }  
     return instance;  
   }  
}   

{% endhighlight %}

这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。
在Android源码中使用的该单例方法有：InputMethodManager，AccessibilityManager等都是使用这种单例模式。

<!-- more -->

3. 懒汉式变种,双重检验锁 (Double Check Locking) (DCL)

{% highlight java %}
public class Singleton {    
  
   private static Singleton instance = null;    
     
  // 只在第一次初始化的时候加上同步锁*/  
  public static Singleton getInstance() {  
      if (instance == null) {  
          synchronized (Singleton.class) {  
              if (instance == null) {  
                  instance = new Singleton();  
              }  
          }  
      }  
      return instance;  
  }  
}   

{% endhighlight %}

这种方法貌似很完美的解决了上述效率的问题，它或许在并发量不多，安全性不太高的情况能完美运行，但是，这种方法也有不幸的地方。问题就是出现在这句
{% highlight java %}
instance = new Singleton(); 
{% endhighlight %}
在JVM编译的过程中会出现指令重排的优化过程，这就会导致当 instance实际上还没初始化，就可能被分配了内存空间，也就是说会出现 instance !=null 但是又没初始化的情况，这样就会导致返回的 instance 不完整。

