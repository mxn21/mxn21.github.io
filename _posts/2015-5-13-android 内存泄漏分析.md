---
layout: post
author: mxn
title: android 内存泄漏分析
category: 技术博文
tag: [android]
---

### 什么是内存泄漏

一些对象有着有限的生命周期。当这些对象所要做的事情完成了，我们希望他们会被回收掉。但是如果有一系列对这个对象的引用，那么在这个对象生命周期结束的时候，它是不会被回收的。它还会占用内存，这就造成了内存泄露。持续累加，内存很快被耗尽。

比如，当 Activity.onDestroy 被调用之后，activity 以及它涉及到的 view 和相关的 bitmap 都应该被回收。但是，如果有一个后台线程持有这个 activity 的引用，那么 activity 对应的内存就不能被回收。这最终将会导致内存耗尽，然后因为 OOM 而 crash。


### 内存泄漏的原因

#### 1、非静态内部类的静态实例容易造成内存泄漏

#### activity使用静态成员，Context泄漏

{% highlight c %}
private static Drawable sBackground;  
@Override  
protected void onCreate(Bundle state) {  
  super.onCreate(state);  
  
  TextView label = new TextView(this);  
  label.setText("Leaks are bad");  
  
  if (sBackground == null) {  
    sBackground = getDrawable(R.drawable.large_bitmap);  
  }  
  label.setBackgroundDrawable(sBackground);  
  
  setContentView(label);  
}  

{% endhighlight %}


这段代码效率很快，但同时又是极其错误的； 在第一次屏幕方向切换时它泄露了一开始创建的Activity。当一个Drawable附加到一个 View上时， View会将其作为一个callback设定到Drawable上。上述的代码片段，意味着这个静态的Drawable拥有一个TextView的引用， 
而TextView又拥有Activity（Context类型）的引用，换句话说，Drawable拥有了更多的对象引用。即使Activity被 销毁，内存仍然不会被释放。 
另外，对Context的引用超过它本身的生命周期，也会导致该Context无法回收，从而导致内存泄漏。所以尽量使用Application这种Context类型。 
这种Context拥有和应用程序一样长的生命周期，并且不依赖Activity的生命周期。如果你打算保存一个长时间的对象， 
并且其需要一个 Context，记得使用Application对象。你可以通过调用Context.getApplicationContext()或 Activity.getApplication()轻松得到Application对象。 


总结一下避免Context泄漏应该注意的问题： 
1.尽量使用Application这种Context类型。 
2.注意对Context的引用不要超过它本身的生命周期。 
3.慎重的对Context使用“static”关键字。 
4.Context里如果有线程，一定要在onDestroy()里及时停掉。 

#### 使用handler时的内存问题
#### 注册某个对象后未反注册
#### 集合中对象没清理造成的内存泄露

#### 资源对象没关闭造成的内存泄露




### 如何查找内存泄漏 
