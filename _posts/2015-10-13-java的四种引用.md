---
layout: post
author: mxn
titile: java的四种引用
category: 技术博文
tag: java
---

Java中存在四种引用，它们分别是：强引用(StrongReference),软引用(SoftReference),弱引用(WeakReference),虚引用(PhantomReference).
下面分别介绍:

## 强引用(StrongReference)

强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，
使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

实际编码中最常见的一种引用类型。常见形式如：A a = new A();等。强引用本身存储在栈内存中，其存储指向对内存中对象的地址。一般情况下，
当对内存中的对象不再有任何强引用指向它时，垃圾回收机器开始考虑可能要对此内存进行的垃圾回收。如当进行编码：a = null，
此时，刚刚在堆中分配地址并新建的a对象没有其他的任何引用，当系统进行垃圾回收时，堆内存将被垃圾回收。

SoftReference、WeakReference、PhantomReference都是类java.lang.ref.Reference的子类。Reference作为抽象基类，
定义了其子类对象的基本操作。Reference子类都具有如下特点：
1.Reference子类不能无参化直接创建，必须至少以强引用对象为构造参数，创建各自的子类对象；
2.因为1中以强引用对象为构造参数创建对象，因此，使得原本强引用所指向的堆内存中的对象将不再只与强引用本身直接关联，
与Reference的子类对象的引用也有一定联系。且此种联系将可能影响到对象的垃圾回收。

根据不同的子类对象对其指示对象（强引用所指向的堆内存中的对象）的垃圾回收不同的影响特点，分别形成了三个子类，即SoftReference、WeakReference和PhantomReference。

<!-- more -->

## 软引用(SoftReference)

如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，
该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

软引用的一般使用形式如下：
A a = new A();
SoftReference<A> srA = new SoftReference<A>(a);

通过对象的强引用为参数，创建了一个SoftReference对象，并使栈内存中的wrA指向此对象。

此时，进行如下编码：a = null，对于原本a所指向的A对象的垃圾回收有什么影响呢？

先直接看一下下面一段程序的输出结果：

{% highlight java %}
import java.lang.ref.SoftReference;

public class ReferenceTest {
     public static void main(String[] args) {
        A a = new A();
         SoftReference<A> srA = new SoftReference<A>(a);
        a = null;
         if (srA.get() == null) {
            System.out.println("a对象进入垃圾回收流程");
         } else {
             System.out.println("a对象尚未被回收" + srA.get());
         }
         // 垃圾回收
        System.gc();
        if (srA.get() == null) {
             System.out.println("a对象进入垃圾回收流程");
         } else {
            System.out.println("a对象尚未被回收" + srA.get());
         }
     }
 }

 class A {

 }
{% endhighlight  %}

输出结果为：

{% highlight c %}
a对象尚未被回收A@4807ccf6
a对象尚未被回收A@4807ccf6
{% endhighlight  %}

当 a = null后，堆内存中的A对象将不再有任何的强引用指向它，但此时尚存在srA引用的对象指向A对象。当第一次调用srA.get()方法返回此指示对象时，
由于垃圾回收器很有可能尚未进行垃圾回收，此时get()是有结果的，这个很好理解。当程序执行System.gc();强制垃圾回收后，
通过srA.get()，发现依然可以得到所指示的A对象，说明A对象并未被垃圾回收。那么，软引用所指示的对象什么时候才开始被垃圾回收呢？需要满足如下两个条件：

```1.当其指示的对象没有任何强引用对象指向它；```
```2.当虚拟机内存不足时。```

```因此，SoftReference变相的延长了其指示对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收器才回收此堆内存空间.```


## 弱引用(WeakReference)

弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，
不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

## 虚引用(PhantomReference)

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，
在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。
当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。


## 总结

待续