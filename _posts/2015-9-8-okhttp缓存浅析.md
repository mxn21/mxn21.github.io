---
layout: post
author: mxn
titile: okhttp缓存浅析
category: 技术博文
tag: android
---

下面是关于OKHttp的请求流程图

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img95.png)

## 拦截器Interceptors

先来看看Interceptor本身的文档解释：观察，修改以及可能短路的请求输出和响应请求的回来。通常情况下拦截器用来添加，移除或者转换请求或者回应的头部信息。
拦截器接口中有intercept(Chain chain)方法，同时返回Response。

## 缓存配置

开启缓存可以通过如下代码

    {% highlight java  %}
    OkHttpClient okHttpClient = new OkHttpClient();
    if(mSetCache)
                setCache(okHttpClient);
    .......

    private static void setCache(OkHttpClient okHttpClient) {
            File cacheDirectory = new File(LSApp.getApplication().getExternalCacheDir(), "HttpCache");

            okHttpClient.networkInterceptors().add(REWRITE_CACHE_CONTROL_INTERCEPTOR);
            Cache cache = new Cache(cacheDirectory, SIZE_OF_CACHE);

            try {
                okHttpClient.setCache(cache);
            } catch (Exception e) {

            }
        }
    {% endhighlight %}

上面设置了缓存路径，在项目包的目录下面的HttpCache文件夹中，然后设置了名为REWRITE_CACHE_CONTROL_INTERCEPTOR的拦截器。
然后实例化Cache，最后调用okHttpClient.setCache(cache);进入setCache一探究竟。

    {% highlight java  %}

     public OkHttpClient setCache(Cache cache) {
        this.cache = cache;
        this.internalCache = null;
        return this;
      }
     {% endhighlight %}

可以看到讲我们的配置的cache保存在了OkHttpClient对象中.

下面去看我们要分析的核心类Cache：

    {% highlight java  %}
public final class Cache {
  private static final int VERSION = 201105;
  private static final int ENTRY_METADATA = 0;
  private static final int ENTRY_BODY = 1;
  private static final int ENTRY_COUNT = 2;
  ....
  }
     {% endhighlight %}

首先Cache里面有四个常量，第一个可以看出是版本号，后三个的作用后面会介绍。

接下来定义了一个对象private final DiskLruCache cache;这个是装饰模式里面的被装饰的对象，也是Cache里面的核心对象。
Cache的作用只是对DiskLruCache的装饰，而DiskLruCache里面有最核心、最原始、最基本的接口或抽象类的实现。

接下来重点分析最核心的一个方法：get方法。

    {% highlight java  %}

Response get(Request request) {
    String key = urlToKey(request);
    DiskLruCache.Snapshot snapshot;
    Entry entry;
    try {
      snapshot = cache.get(key);
      if (snapshot == null) {
        return null;
      }
    } catch (IOException e) {
      // Give up because the cache cannot be read.
      return null;
    }

    try {
      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
    } catch (IOException e) {
      Util.closeQuietly(snapshot);
      return null;
    }

    Response response = entry.response(request, snapshot);

    if (!entry.matches(request, response)) {
      Util.closeQuietly(response.body());
      return null;
    }

    return response;
  }

  private static String urlToKey(Request request) {
      return Util.md5Hex(request.urlString());
    }

     {% endhighlight %}

可以看出，这个方法传入的是request，返回了Response。说明这个就是取出缓存的核心方法。

第一步调用了urlToKey取得request的URL进行MD5加密，然后作为request的唯一标示key。
接着声明snapshot和entry，它们都是用来保存Response的。然后  snapshot = cache.get(key);取出返回内容。
进入DiskLruCache的get看源码：


    {% highlight java  %}
public synchronized Snapshot get(String key) throws IOException {
    initialize();

    checkNotClosed();
    validateKey(key);
    Entry entry = lruEntries.get(key);
    if (entry == null || !entry.readable) return null;

    Snapshot snapshot = entry.snapshot();
    if (snapshot == null) return null;

    redundantOpCount++;
    journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
    if (journalRebuildRequired()) {
      executor.execute(cleanupRunnable);
    }

    return snapshot;
  }

    {% endhighlight %}

首先调用初始化方法 initialize();

    {% highlight java  %}
void initialize() throws IOException {
    assert Thread.holdsLock(this);

    if (initialized) {
      return; // Already initialized.
    }

    // If a bkp file exists, use it instead.
    if (fileSystem.exists(journalFileBackup)) {
      // If journal file also exists just delete backup file.
      if (fileSystem.exists(journalFile)) {
        fileSystem.delete(journalFileBackup);
      } else {
        fileSystem.rename(journalFileBackup, journalFile);
      }
    }

    // Prefer to pick up where we left off.
    if (fileSystem.exists(journalFile)) {
      try {
        readJournal();
        processJournal();
        initialized = true;
        return;
      } catch (IOException journalIsCorrupt) {
        Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
            + journalIsCorrupt.getMessage() + ", removing");
        delete();
        closed = false;
      }
    }

    rebuildJournal();

    initialized = true;
  }
    {% endhighlight %}

可以看到里面主要在处理journalFile这个文件，这个journalFile是什么呢。如果我们进入缓存目录就能发现问题。

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img96.png)

发现缓存文件全是以url的md5加密字段为文件名，每一个response分两个文件保存，以.0和.1结尾的文件区分。
进去看里面的内容如下：
.0的文件里面是header：

    {% highlight c  %}
http://58.210.161.178:8088/lngiot-api/v1/mobile/device/9B80F22B51C64E488C09D37990063D06/module/1727/history?start=1441443443645&end=1441529843645&expectPoint=200%20
GET
0
HTTP/1.1 200 OK
8
Server: Apache-Coyote/1.1
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Sun, 06 Sep 2015 08:56:44 GMT
OkHttp-Selected-Protocol: http/1.1
OkHttp-Sent-Millis: 1441529843654
OkHttp-Received-Millis: 1441529844035
Cache-Control: max-age=864000000, only-if-cached, max-stale=0
      {% endhighlight %}

而.1文件里面是返回的具体内容，即json数据。

而文件夹最后还有一个journal.文件，这个里面是什么呢。

    {% highlight c  %}

libcore.io.DiskLruCache
1
201105
2

DIRTY 8c1fab929dcb34407d05366415626994
REMOVE 8c1fab929dcb34407d05366415626994
DIRTY e51a1dad8e596e1844109d27b73ff551
CLEAN e51a1dad8e596e1844109d27b73ff551 2327 80
DIRTY c693ba810f44727d37d2edc11eb76e76
CLEAN c693ba810f44727d37d2edc11eb76e76 420 2919
DIRTY c693ba810f44727d37d2edc11eb76e76
CLEAN c693ba810f44727d37d2edc11eb76e76 420 2919
DIRTY a350c5ffc000d8140cdc6e1f6ec88799
CLEAN a350c5ffc000d8140cdc6e1f6ec88799 407 672
DIRTY 9ca0cc1c6e8190f5d2ec6108dd6b3822
CLEAN 9ca0cc1c6e8190f5d2ec6108dd6b3822 409 2356
DIRTY 7bbe640ea6195fe53960b5393d9d88d3
CLEAN 7bbe640ea6195fe53960b5393d9d88d3 492 13439
DIRTY 8c1fab929dcb34407d05366415626994
CLEAN 8c1fab929dcb34407d05366415626994 388 199
READ c693ba810f44727d37d2edc11eb76e76
READ c693ba810f44727d37d2edc11eb76e76
DIRTY e39dad184a3de2a623f6587f6605e754
CLEAN e39dad184a3de2a623f6587f6605e754 407 565

      {% endhighlight %}

可以看到里面保存的是每一条reponse记录状态。包括读取，删除，写入等动作。

因此刚才initialize方法就是在读取这个文件，截取前面的动作，去掉remove动作的文件，其他的文件名加入到内存中保存。
然后就是根据key取得内容了Entry entry = lruEntries.get(key);
而lruEntries是一个map对象，以url的md5形式作为key：  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);

再回到Cache中的snapshot = cache.get(key);这行，现在已经取得了snapshot，接着entry = new Entry(snapshot.getSource(ENTRY_METADATA));
然后Response response = entry.response(request, snapshot);这样就取得了response。

snapshot.getSource(ENTRY_METADATA)




