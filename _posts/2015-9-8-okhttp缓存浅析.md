---
layout: post
author: mxn
titile: okhttp缓存浅析
category: 技术博文
tag: android
---

下面是关于OKHttp的请求流程图

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img95.png)

## 拦截器Interceptors

先来看看Interceptor本身的文档解释：观察，修改以及可能短路的请求输出和响应请求的回来。通常情况下拦截器用来添加，移除或者转换请求或者回应的头部信息。
拦截器接口中有intercept(Chain chain)方法，同时返回Response。

## 缓存配置

开启缓存可以通过如下代码

    {% highlight java  %}
    OkHttpClient okHttpClient = new OkHttpClient();
    if(mSetCache)
                setCache(okHttpClient);
    .......

    private static void setCache(OkHttpClient okHttpClient) {
            File cacheDirectory = new File(LSApp.getApplication().getExternalCacheDir(), "HttpCache");

            okHttpClient.networkInterceptors().add(REWRITE_CACHE_CONTROL_INTERCEPTOR);
            Cache cache = new Cache(cacheDirectory, SIZE_OF_CACHE);

            try {
                okHttpClient.setCache(cache);
            } catch (Exception e) {

            }
        }
    {% endhighlight %}

上面设置了缓存路径，在项目包的目录下面的HttpCache文件夹中，然后设置了名为REWRITE_CACHE_CONTROL_INTERCEPTOR的拦截器。
然后实例化Cache，最后调用okHttpClient.setCache(cache);进入setCache一探究竟。

    {% highlight java  %}

     public OkHttpClient setCache(Cache cache) {
        this.cache = cache;
        this.internalCache = null;
        return this;
      }
     {% endhighlight %}

可以看到讲我们的配置的cache保存在了OkHttpClient对象中.

下面去看我们要分析的核心类Cache：

    {% highlight java  %}
public final class Cache {
  private static final int VERSION = 201105;
  private static final int ENTRY_METADATA = 0;
  private static final int ENTRY_BODY = 1;
  private static final int ENTRY_COUNT = 2;
  ....
  }
     {% endhighlight %}

首先Cache里面有四个常量，第一个可以看出是版本号，后三个的作用后面会介绍。

