---
layout: post
author: mxn
titile: okhttp缓存浅析
category: 技术博文
tag: android
---

下面是关于OKHttp的请求流程图

![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img95.png)

## 拦截器Interceptors

先来看看Interceptor本身的文档解释：观察，修改以及可能短路的请求输出和响应请求的回来。通常情况下拦截器用来添加，移除或者转换请求或者回应的头部信息。
拦截器接口中有intercept(Chain chain)方法，同时返回Response。

## 缓存配置

开启缓存可以通过如下代码

    {% highlight java  %}
    OkHttpClient okHttpClient = new OkHttpClient();
    if(mSetCache)
                setCache(okHttpClient);
    .......

    private static void setCache(OkHttpClient okHttpClient) {
            File cacheDirectory = new File(LSApp.getApplication().getExternalCacheDir(), "HttpCache");

            okHttpClient.networkInterceptors().add(REWRITE_CACHE_CONTROL_INTERCEPTOR);
            Cache cache = new Cache(cacheDirectory, SIZE_OF_CACHE);

            try {
                okHttpClient.setCache(cache);
            } catch (Exception e) {

            }
        }
    {% endhighlight %}

上面设置了缓存路径，在项目包的目录下面的HttpCache文件夹中，然后设置了名为REWRITE_CACHE_CONTROL_INTERCEPTOR的拦截器。
然后实例化Cache，最后调用okHttpClient.setCache(cache);进入setCache一探究竟。

    {% highlight java  %}

     public OkHttpClient setCache(Cache cache) {
        this.cache = cache;
        this.internalCache = null;
        return this;
      }
     {% endhighlight %}

可以看到讲我们的配置的cache保存在了OkHttpClient对象中.

下面去看我们要分析的核心类Cache：

    {% highlight java  %}
public final class Cache {
  private static final int VERSION = 201105;
  private static final int ENTRY_METADATA = 0;
  private static final int ENTRY_BODY = 1;
  private static final int ENTRY_COUNT = 2;
  ....
  }
     {% endhighlight %}

首先Cache里面有四个常量，第一个可以看出是版本号，后三个的作用后面会介绍。

接下来定义了一个对象private final DiskLruCache cache;这个是装饰模式里面的被装饰的对象，也是Cache里面的核心对象。
Cache的作用只是对DiskLruCache的装饰，而DiskLruCache里面有最核心、最原始、最基本的接口或抽象类的实现。

接下来重点分析最核心的一个方法：get方法。

    {% highlight java  %}

Response get(Request request) {
    String key = urlToKey(request);
    DiskLruCache.Snapshot snapshot;
    Entry entry;
    try {
      snapshot = cache.get(key);
      if (snapshot == null) {
        return null;
      }
    } catch (IOException e) {
      // Give up because the cache cannot be read.
      return null;
    }

    try {
      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
    } catch (IOException e) {
      Util.closeQuietly(snapshot);
      return null;
    }

    Response response = entry.response(request, snapshot);

    if (!entry.matches(request, response)) {
      Util.closeQuietly(response.body());
      return null;
    }

    return response;
  }

  private static String urlToKey(Request request) {
      return Util.md5Hex(request.urlString());
    }

     {% endhighlight %}

可以看出，这个方法传入的是request，返回了Response。说明这个就是取出缓存的核心方法。

第一步调用了urlToKey取得request的URL进行MD5加密，然后作为request的唯一标示key。
接着声明snapshot和entry，它们都是用来保存Response的。然后  snapshot = cache.get(key);取出返回内容。
进入DiskLruCache的get看源码：


    {% highlight java  %}
public synchronized Snapshot get(String key) throws IOException {
    initialize();

    checkNotClosed();
    validateKey(key);
    Entry entry = lruEntries.get(key);
    if (entry == null || !entry.readable) return null;

    Snapshot snapshot = entry.snapshot();
    if (snapshot == null) return null;

    redundantOpCount++;
    journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
    if (journalRebuildRequired()) {
      executor.execute(cleanupRunnable);
    }

    return snapshot;
  }

    {% endhighlight %}

首先调用初始化方法 initialize();

    {% highlight java  %}
void initialize() throws IOException {
    assert Thread.holdsLock(this);

    if (initialized) {
      return; // Already initialized.
    }

    // If a bkp file exists, use it instead.
    if (fileSystem.exists(journalFileBackup)) {
      // If journal file also exists just delete backup file.
      if (fileSystem.exists(journalFile)) {
        fileSystem.delete(journalFileBackup);
      } else {
        fileSystem.rename(journalFileBackup, journalFile);
      }
    }

    // Prefer to pick up where we left off.
    if (fileSystem.exists(journalFile)) {
      try {
        readJournal();
        processJournal();
        initialized = true;
        return;
      } catch (IOException journalIsCorrupt) {
        Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
            + journalIsCorrupt.getMessage() + ", removing");
        delete();
        closed = false;
      }
    }

    rebuildJournal();

    initialized = true;
  }
    {% highlight java  %}

可以看到里面主要在处理journalFile这个文件，这个journalFile是什么呢。如果我们进入缓存目录就能发现问题。

