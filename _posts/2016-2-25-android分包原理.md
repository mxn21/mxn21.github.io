---
layout: post
author: mxn
titile: android分包原理
category: 技术博文
tag: android
---

如果App引用的库太多，方法数超过65536后无法编译。这是因为单个dex里面不能有超过65536个方法。为什么有最大的限制呢，
因为android会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，
short占两个字节（保存-2的15次方到2的15次方-1，即-32768~32767），最大保存的数量就是65536。新版本的Android系统中修复了这个问题，
但是我们仍然需要对低版本的Android系统做兼容.

解决方法有如下几个：
1.精简方法数量,删除没用到的类、方法、第三方库。
2.使用ProGuard去掉一些未使用的代码
3.复杂模块采用jni的方式实现，也可以对边缘模块采用本地插件化的方式。
4.分割Dex

本文只介绍最后一种方法。

## multidex方案配置

dex文件拆成两个或多个，为此谷歌官方推出了multidex兼容包，配合AndroidStudio实现了一个APK包含多个dex的功能。
Android 的 Gradle插件在 Android Build Tool 21.1开始就支持使用multidex了。

#### 使用步骤

使用步骤包括：
1.修改Gradle的配置，支持multidex
2.修改你的manifest。让其支持multidexapplication类

注意其中第二步其实还有另外两种替代方法，下面介绍。 

修改Gradle的配置，支持multidex:

	{% highlight c  %}
android {
    compileSdkVersion 21
    buildToolsVersion "21.1.0"
    defaultConfig {
        ...
        minSdkVersion 14
        targetSdkVersion 21
        ...
        // Enabling multidex support.
        multiDexEnabled true
    }
    ...
}
dependencies {
  compile 'com.android.support:multidex:1.0.0'
}
	{% endhighlight %}
	
你可以在Gradle配置文件中的defaultConfig、 buildType、productFlavor中设置 multiDexEnabled true。

在manifest文件中，在application标签下添加MultidexApplication Class的引用，如下所示：

	{% highlight xml  %}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.android.multidex.myapplication">
    <application
        ...
        android:name="android.support.multidex.MultiDexApplication">
        ...
    </application>
</manifest>
	{% endhighlight %}

当然，如果你重写了Application，可以让自定义Applicationd继承android.support.multidex.MultiDexApplication。

如果之前已经继承了其他Application类，可以重写attachBaseContext()方法，并添加语句MultiDex.install(this);如下：

	{% highlight java  %}
public class MyApplication extends BaseApplication{
    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        MultiDex.install(this);
    }
}
	{% endhighlight %}

注意事项:Application 中的静态全局变量会比MutiDex的 instal()方法优先加载，所以建议避免在Application类中使用静态变量引用
main classes.dex文件以外dex文件中的类，可以根据如下所示的方式进行修改:

	{% highlight java  %}
@Override  
    public void onCreate() {  
        super.onCreate();  
        final Context mContext = this;  
        new Runnable() {  
            @Override  
            public void run() {  
                // put your logic here!  
                // use the mContext instead of this here  
            }  
        }.run();  
    }  
	{% endhighlight %}

#### Multidex的局限性

官方文档中提到了Multidex有局限性：

1.如果第二个（或其他个）dex文件很大的话，安装.dex文件到data分区时可能会导致ANR（应用程序无响应）,此时应该使用ProGuard减小DEX文件的大小。
2.由于Dalvik linearAlloc的bug的关系，使用了multidex的应用可能无法在Android 4.0 (API level 14)或之前版本的设备上运行。
3.由于Dalvik linearAlloc的限制，使用了multidex的应用会请求非常大的内存分配，从而导致程序奔溃。Dalvik linearAlloc是一个固定大小的缓冲区。
在应用的安装过程中，系统会运行一个名为dexopt的程序为该应用在当前机型中运行做准备。dexopt使用LinearAlloc来存储应用的方法信息。
Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB或16MB。当方法数量过多导致超出缓冲区大小时，会造成dexopt崩溃。
4.在Dalvik运行时中，某些类的方法必须要放在主dex中，Android构建工具可能无法确保所有有此要求的类被编译进主dex中。

这些问题也非常值得我们关注.

一些在二级Dex加载之前,可能会被调用到的类(比如静态变量的类),需要放在主Dex中.否则会ClassNotFoundError.
通过修改Gradle,可以显式的把一些类放在Main Dex中.

	{% highlight c  %}
afterEvaluate {
    tasks.matching {
        it.name.startsWith('dex')
    }.each { dx ->
        if (dx.additionalParameters == null) {
            dx.additionalParameters = []
        }
        dx.additionalParameters += '--multi-dex'
        dx.additionalParameters += "--main-dex-list=$projectDir/<filename>".toString()
    }
}
	{% endhighlight %}
	
上面是修改后的Gradle,其中<filename>是一个文本文件的文件名,存放在和这个Gradle脚本同一级的文件目录下.
而这个文本文件的内容如下.实际就是把需要放在Main Dex的类罗列出来.	

	{% highlight   %}
android/support/multidex/BuildConfig/class
android/support/multidex/MultiDex$V14/class
android/support/multidex/MultiDex$V19/class
android/support/multidex/MultiDex$V4/class
android/support/multidex/MultiDex/class
android/support/multidex/MultiDexApplication/class
android/support/multidex/MultiDexExtractor$1/class
android/support/multidex/MultiDexExtractor/class
android/support/multidex/ZipUtil$CentralDirectory/class
android/support/multidex/ZipUtil/class
	{% endhighlight %}

project.afterEvaluate标签在特定的project配置完成后运行，而gradle.projectsEvaluated在所有projects配置完成后运行。

如果用使用其他Lib,要保证这些Lib没有被preDex,否则可能会抛出下面的异常：

	{% highlight   %}
UNEXPECTED TOP-LEVEL EXCEPTION:
    com.android.dex.DexException: Library dex files are not supported in multi-dex mode
        at com.android.dx.command.dexer.Main.runMultiDex(Main.java:337)
        at com.android.dx.command.dexer.Main.run(Main.java:243)
        at com.android.dx.command.dexer.Main.main(Main.java:214)
        at com.android.dx.command.Main.main(Main.java:106)
	{% endhighlight %}

遇到这个异常,需要在Gradle中修改,让它不要对Lib做preDexing

	{% highlight c  %}
	android {
    //  ...
        dexOptions {
            preDexLibraries = false
        }
    }
	{% endhighlight %}
	
如果每次都打开MultiDex编译版本的话,会比平常用更多的时间.
Android的官方文档也给了我们一个小小的建议,利用Gradle建立两个Flavor.一个minSdkVersion设置成21,这是用了ART支持的Dex格式,
避免了MultiDex的开销.而另外一个Flavor就是原本支持的最小sdkVersion.平时开发时候调试程序,就用前者的Flavor,
发布版本打包就用后者的Flavor.

	{% highlight c  %}
android {
    productFlavors {
        // Define separate dev and prod product flavors.
        dev {
            // dev utilizes minSDKVersion = 21 to allow the Android gradle plugin
            // to pre-dex each module and produce an APK that can be tested on
            // Android Lollipop without time consuming dex merging processes.
            minSdkVersion 21
        }
        prod {
            // The actual minSdkVersion for the application.
            minSdkVersion 14
        }
    }
          ...
    buildTypes {
        release {
            runProguard true
            proguardFiles getDefaultProguardFile('proguard-android.txt'),
                                                 'proguard-rules.pro'
        }
    }
}
dependencies {
  compile 'com.android.support:multidex:1.0.0'
}
	{% endhighlight %}
	
	
#### MultiDex实现原理

Apk在运行的时候，有一个dexpathlist，而Multidex的源码中，会根据你的系统版本号对dexpathlist做修改，将所有的dex都添加到dexpathlist中.

再来看看MultiDex.install（）的流程：

1.android.support.multidex.MultiDex.V14#install()
2.android.support.multidex.MultiDex.V14#makeDexElements();

通过反射调用了DexPathList 的makeDexElements()，该方法就是调用dex = loadDexFile(file, optimizedDirectory);

看看 loadDexFile

	{% highlight java  %}
/**
 * Constructs a {@code DexFile} instance, as appropriate depending
 * on whether {@code optimizedDirectory} is {@code null}.
 */
 private static DexFile loadDexFile(File file, File optimizedDirectory)
 throws IOException {
 if (optimizedDirectory == null) {
 return new DexFile(file);
 } else {
 String optimizedPath = optimizedPathFor(file, optimizedDirectory);
 return DexFile.loadDex(file.getPath(), optimizedPath, 0);
 }
 }
	{% endhighlight %}

第一次load dex文件的时候 是 optimizedDirectory 空的 。 进入 return new DexFile(file); 的分支。

	{% highlight java  %}
/*
* Open a DEX file. The value returned is a magic VM cookie. On
* failure, an IOException is thrown.
*/
native private static int openDexFile(String sourceName, String outputName,
int flags) throws IOException;
	{% endhighlight %}

进入native层代码openDexFile():

	{% highlight c  %}
static void Dalvik_dalvik_system_DexFile_openDexFile(const u4* args,
JValue* pResult)
	{% endhighlight %}

在其中调用了dvmJarFileOpen()方法，在 android/dalvik/vm/JarFile.cpp

	{% highlight c  %}
/*
 * Open a Jar file. It's okay if it's just a Zip archive without all of
 * the Jar trimmings, but we do insist on finding "classes.dex" inside
 * or an appropriately-named ".odex" file alongside.
 *
 * If "isBootstrap" is not set, the optimizer/verifier regards this DEX as
 * being part of a different class loader.
 */
int dvmJarFileOpen(const char* fileName, const char* odexOutputName,
 JarFile** ppJarFile, bool isBootstrap)
{
 /*
 * TODO: This function has been duplicated and modified to become
 * dvmRawDexFileOpen() in RawDexFile.c. This should be refactored.
 */
 ZipArchive archive;
 DvmDex* pDvmDex = NULL;
 char* cachedName = NULL;
 bool archiveOpen = false;
 bool locked = false;
 int fd = -1;
 int result = -1;
 /* Even if we're not going to look at the archive, we need to
 * open it so we can stuff it into ppJarFile.
 */
 if (dexZipOpenArchive(fileName, &archive) != 0)
 goto bail;
 archiveOpen = true;
 /* If we fork/exec into dexopt, don't let it inherit the archive's fd.
 */
 dvmSetCloseOnExec(dexZipGetArchiveFd(&archive));
 /* First, look for a ".odex" alongside the jar file. It will
 * have the same name/path except for the extension.
 */
 fd = openAlternateSuffix(fileName, "odex", O_RDONLY, &cachedName);
 if (fd >= 0) {
 ALOGV("Using alternate file (odex) for %s ...", fileName);
 if (!dvmCheckOptHeaderAndDependencies(fd, false, 0, 0, true, true)) {
 ALOGE("%s odex has stale dependencies", fileName);
 free(cachedName);
 cachedName = NULL;
 close(fd);
 fd = -1;
 goto tryArchive;
 } else {
 ALOGV("%s odex has good dependencies", fileName);
 //TODO: make sure that the .odex actually corresponds
 // to the classes.dex inside the archive (if present).
 // For typical use there will be no classes.dex.
 }
 } else {
 ZipEntry entry;
tryArchive:
 /*
 * Pre-created .odex absent or stale. Look inside the jar for a
 * "classes.dex".
 */
 entry = dexZipFindEntry(&archive, kDexInJarName);
 if (entry != NULL) {
 bool newFile = false;
 /*
 * We've found the one we want. See if there's an up-to-date copy
 * in the cache.
 *
 * On return, "fd" will be seeked just past the "opt" header.
 *
 * If a stale .odex file is present and classes.dex exists in
 * the archive, this will *not* return an fd pointing to the
 * .odex file; the fd will point into dalvik-cache like any
 * other jar.
 */
 if (odexOutputName == NULL) {
 cachedName = dexOptGenerateCacheFileName(fileName,
 kDexInJarName);
 if (cachedName == NULL)
 goto bail;
 } else {
 cachedName = strdup(odexOutputName);
 }
 ALOGV("dvmJarFileOpen: Checking cache for %s (%s)",
 fileName, cachedName);
 fd = dvmOpenCachedDexFile(fileName, cachedName,
 dexGetZipEntryModTime(&archive, entry),
 dexGetZipEntryCrc32(&archive, entry),
 isBootstrap, &newFile, /*createIfMissing=*/true);
 if (fd < 0) {
 ALOGI("Unable to open or create cache for %s (%s)",
 fileName, cachedName);
 goto bail;
 }
 locked = true;
 /*
 * If fd points to a new file (because there was no cached version,
 * or the cached version was stale), generate the optimized DEX.
 * The file descriptor returned is still locked, and is positioned
 * just past the optimization header.
 */
 if (newFile) {
 u8 startWhen, extractWhen, endWhen;
 bool result;
 off_t dexOffset;
 dexOffset = lseek(fd, 0, SEEK_CUR);
 result = (dexOffset > 0);
 if (result) {
 startWhen = dvmGetRelativeTimeUsec();
 result = dexZipExtractEntryToFile(&archive, entry, fd) == 0;
 extractWhen = dvmGetRelativeTimeUsec();
 }
 if (result) {
 result = dvmOptimizeDexFile(fd, dexOffset,
 dexGetZipEntryUncompLen(&archive, entry),
 fileName,
 dexGetZipEntryModTime(&archive, entry),
 dexGetZipEntryCrc32(&archive, entry),
 isBootstrap);
 }
 if (!result) {
 ALOGE("Unable to extract+optimize DEX from '%s'",
 fileName);
 goto bail;
 }
 endWhen = dvmGetRelativeTimeUsec();
 ALOGD("DEX prep '%s': unzip in %dms, rewrite %dms",
 fileName,
 (int) (extractWhen - startWhen) / 1000,
 (int) (endWhen - extractWhen) / 1000);
 }
 } else {
 ALOGI("Zip is good, but no %s inside, and no valid .odex "
 "file in the same directory", kDexInJarName);
 goto bail;
 }
 }
 /*
 * Map the cached version. This immediately rewinds the fd, so it
 * doesn't have to be seeked anywhere in particular.
 */
 if (dvmDexFileOpenFromFd(fd, &pDvmDex) != 0) {
 ALOGI("Unable to map %s in %s", kDexInJarName, fileName);
 goto bail;
 }
 if (locked) {
 /* unlock the fd */
 if (!dvmUnlockCachedDexFile(fd)) {
 /* uh oh -- this process needs to exit or we'll wedge the system */
 ALOGE("Unable to unlock DEX file");
 goto bail;
 }
 locked = false;
 }
 ALOGV("Successfully opened '%s' in '%s'", kDexInJarName, fileName);
 *ppJarFile = (JarFile*) calloc(1, sizeof(JarFile));
 (*ppJarFile)->archive = archive;
 (*ppJarFile)->cacheFileName = cachedName;
 (*ppJarFile)->pDvmDex = pDvmDex;
 cachedName = NULL; // don't free it below
 result = 0;
bail:
 /* clean up, closing the open file */
 if (archiveOpen && result != 0)
 dexZipCloseArchive(&archive);
 free(cachedName);
 if (fd >= 0) {
 if (locked)
 (void) dvmUnlockCachedDexFile(fd);
 close(fd);
 }
 return result;
}
	{% endhighlight %}
	
其中 , 执行了dvmOpenCachedDexFile（）后 newFile 为true 。 会执行

	{% highlight java  %}
	result = dvmOptimizeDexFile(fd, dexOffset,
     dexGetZipEntryUncompLen(&archive, entry),
     fileName,
     dexGetZipEntryModTime(&archive, entry),
     dexGetZipEntryCrc32(&archive, entry),
     isBootstrap);
	{% endhighlight %}
	
这里调用了 /dalvik/vm/RawDexFile.cpp 中的 dvmOptimizeDexFile()方法

	{% highlight c  %}
/*
 * Given a descriptor for a file with DEX data in it, produce an
 * optimized version.
 *
 * The file pointed to by "fd" is expected to be a locked shared resource
 * (or private); we make no efforts to enforce multi-process correctness
 * here.
 *
 * "fileName" is only used for debug output. "modWhen" and "crc" are stored
 * in the dependency set.
 *
 * The "isBootstrap" flag determines how the optimizer and verifier handle
 * package-scope access checks. When optimizing, we only load the bootstrap
 * class DEX files and the target DEX, so the flag determines whether the
 * target DEX classes are given a (synthetic) non-NULL classLoader pointer.
 * This only really matters if the target DEX contains classes that claim to
 * be in the same package as bootstrap classes.
 *
 * The optimizer will need to load every class in the target DEX file.
 * This is generally undesirable, so we start a subprocess to do the
 * work and wait for it to complete.
 *
 * Returns "true" on success. All data will have been written to "fd".
 */
bool dvmOptimizeDexFile(int fd, off_t dexOffset, long dexLength,
 const char* fileName, u4 modWhen, u4 crc, bool isBootstrap)
{
 const char* lastPart = strrchr(fileName, '/');
 if (lastPart != NULL)
 lastPart++;
 else
 lastPart = fileName;
 ALOGD("DexOpt: --- BEGIN '%s' (bootstrap=%d) ---", lastPart, isBootstrap);
 pid_t pid;
 /*
 * This could happen if something in our bootclasspath, which we thought
 * was all optimized, got rejected.
 */
 if (gDvm.optimizing) {
 ALOGW("Rejecting recursive optimization attempt on '%s'", fileName);
 return false;
 }
 pid = fork();
 if (pid == 0) {
 static const int kUseValgrind = 0;
 static const char* kDexOptBin = "/bin/dexopt";
 static const char* kValgrinder = "/usr/bin/valgrind";
 static const int kFixedArgCount = 10;
 static const int kValgrindArgCount = 5;
 static const int kMaxIntLen = 12; // '-'+10dig+'\0' -OR- 0x+8dig
 int bcpSize = dvmGetBootPathSize();
 int argc = kFixedArgCount + bcpSize
 + (kValgrindArgCount * kUseValgrind);
 const char* argv[argc+1]; // last entry is NULL
 char values [argc][kMaxIntLen];
 char* execFile;
 const char* androidRoot;
 int flags;
 /* change process groups, so we don't clash with ProcessManager */
 setpgid(0, 0);
 /* full path to optimizer */
 androidRoot = getenv("ANDROID_ROOT");
 if (androidRoot == NULL) {
 ALOGW("ANDROID_ROOT not set, defaulting to /system");
 androidRoot = "/system";
 }
 execFile = (char*)alloca(strlen(androidRoot) + strlen(kDexOptBin) + 1);
 strcpy(execFile, androidRoot);
 strcat(execFile, kDexOptBin);
 /*
 * Create arg vector.
 */
 int curArg = 0;
 if (kUseValgrind) {
 /* probably shouldn't ship the hard-coded path */
 argv[curArg++] = (char*)kValgrinder;
 argv[curArg++] = "--tool=memcheck";
 argv[curArg++] = "--leak-check=yes"; // check for leaks too
 argv[curArg++] = "--leak-resolution=med"; // increase from 2 to 4
 argv[curArg++] = "--num-callers=16"; // default is 12
 assert(curArg == kValgrindArgCount);
 }
 argv[curArg++] = execFile;
 argv[curArg++] = "--dex";
 sprintf(values[2], "%d", DALVIK_VM_BUILD);
 argv[curArg++] = values[2];
 sprintf(values[3], "%d", fd);
 argv[curArg++] = values[3];
 sprintf(values[4], "%d", (int) dexOffset);
 argv[curArg++] = values[4];
 sprintf(values[5], "%d", (int) dexLength);
 argv[curArg++] = values[5];
 argv[curArg++] = (char*)fileName;
 sprintf(values[7], "%d", (int) modWhen);
 argv[curArg++] = values[7];
 sprintf(values[8], "%d", (int) crc);
 argv[curArg++] = values[8];
 flags = 0;
 if (gDvm.dexOptMode != OPTIMIZE_MODE_NONE) {
 flags |= DEXOPT_OPT_ENABLED;
 if (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)
 flags |= DEXOPT_OPT_ALL;
 }
 if (gDvm.classVerifyMode != VERIFY_MODE_NONE) {
 flags |= DEXOPT_VERIFY_ENABLED;
 if (gDvm.classVerifyMode == VERIFY_MODE_ALL)
 flags |= DEXOPT_VERIFY_ALL;
 }
 if (isBootstrap)
 flags |= DEXOPT_IS_BOOTSTRAP;
 if (gDvm.generateRegisterMaps)
 flags |= DEXOPT_GEN_REGISTER_MAPS;
 sprintf(values[9], "%d", flags);
 argv[curArg++] = values[9];
 assert(((!kUseValgrind && curArg == kFixedArgCount) ||
 ((kUseValgrind && curArg == kFixedArgCount+kValgrindArgCount))));
 ClassPathEntry* cpe;
 for (cpe = gDvm.bootClassPath; cpe->ptr != NULL; cpe++) {
 argv[curArg++] = cpe->fileName;
 }
 assert(curArg == argc);
 argv[curArg] = NULL;
 if (kUseValgrind)
 execv(kValgrinder, const_cast<char**>(argv));
 else
 execv(execFile, const_cast<char**>(argv));
 ALOGE("execv '%s'%s failed: %s", execFile,
 kUseValgrind ? " [valgrind]" : "", strerror(errno));
 exit(1);
 } else {
 ALOGV("DexOpt: waiting for verify+opt, pid=%d", (int) pid);
 int status;
 pid_t gotPid;
 /*
 * Wait for the optimization process to finish. We go into VMWAIT
 * mode here so GC suspension won't have to wait for us.
 */
 ThreadStatus oldStatus = dvmChangeStatus(NULL, THREAD_VMWAIT);
 while (true) {
 gotPid = waitpid(pid, &status, 0);
 if (gotPid == -1 && errno == EINTR) {
 ALOGD("waitpid interrupted, retrying");
 } else {
 break;
 }
 }
 dvmChangeStatus(NULL, oldStatus);
 if (gotPid != pid) {
 ALOGE("waitpid failed: wanted %d, got %d: %s",
 (int) pid, (int) gotPid, strerror(errno));
 return false;
 }
 if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
 ALOGD("DexOpt: --- END '%s' (success) ---", lastPart);
 return true;
 } else {
 ALOGW("DexOpt: --- END '%s' --- status=0x%04x, process failed",
 lastPart, status);
 return false;
 }
 }
}
	{% endhighlight %}
	
	